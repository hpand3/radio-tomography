<!DOCTYPE html>
<html>
<head>
	<title>3D Radio Tomography</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
		html, body {
		    width: 100%;
		    height: 100%;
		    margin: 0;
		}
		canvas { 
			display: block;
			position: absolute;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
			width: 100%;
			height: 100%;
			overflow: hidden;   /* Disable scrollbars */
			z-index: -1;
		}
	</style>

</head>

<body>

	<script type="text/javascript" src="js/three.js"></script>
	<script type="text/javascript" src="js/OrbitControls.js"></script>
	<script type="text/javascript" src="js/numjs.min.js"></script>
	<script type="text/javascript" src="js/VoxelTraversal.js"></script>
	<script type="text/javascript" src="js/Link.js"></script>
	<script type="text/javascript" src="js/Backprojection.js"></script>
	<script>

	// Dimensions
	var dim = {x:15 , y:10 , z:15};
	var scene,
		renderer,
		cubeGroup,
		wireGroup,
		voxelTrav,
		controls;

	initUSB();
	init();
	render();

	function initUSB() {
		var sp = require('serialport');
		p.list(function(err, ports) {
			console.log(ports);
		});
	}

	function init() {
		// Scene
		scene = new THREE.Scene();

		// Camera
		camera = new THREE.PerspectiveCamera( 65, 
			window.innerWidth/window.innerHeight, 0.1, 1000 );

		// Controls
		controls = new THREE.OrbitControls( camera );
		controls.rotateSpeed = 1.0;
		controls.zoomSpeed = 1.2;
		controls.panSpeed = 0.8;
		controls.target.set(dim["x"]/2, dim["y"]/2, dim["z"]/2);



		// Renderer
		renderer = new THREE.WebGLRenderer();
		renderer.setPixelRatio( window.devicePixelRatio );
		renderer.setSize( window.innerWidth, window.innerHeight );
		renderer.setClearColor (0xe8e8e8, 1);
		
		document.body.appendChild( renderer.domElement );

		// Init vars
		var cubeGeo = new THREE.CubeGeometry( 1, 1, 1 );
		var wireGeo = new THREE.EdgesGeometry( cubeGeo );
		var wireMat = new THREE.LineBasicMaterial( { color: 
			0x000000, transparent: true, opacity: 0.05 } );

		// Mesh group
		cubeGroup = new THREE.Group();
		wireGroup = new THREE.Group();

		// Create cube structure depending on the dimensions
		for(posx = 0; posx < dim["x"]; posx++) {
			for(posy = 0; posy < dim["y"]; posy++) {
				for(posz = 0; posz < dim["z"]; posz++) {
					// Create objects
					var cubeMat = new THREE.MeshBasicMaterial( { color: 
						0xe00b0b, transparent:true, opacity:0.1 } );
					var cube = new THREE.Mesh( cubeGeo, cubeMat );
					var wireframe = new THREE.LineSegments( wireGeo, 
						wireMat );

					// Set cube position
					cube.position.x = posx;
					cube.position.y = posy;
					cube.position.z = posz;

					// Set wireframe position
					wireframe.position.x = posx;
					wireframe.position.y = posy;
					wireframe.position.z = posz;

					// Add to group
					cubeGroup.add( cube );
					wireGroup.add( wireframe );
				}
			}
		}

		// Add groups to the scene
		scene.add(cubeGroup);
		scene.add(wireGroup);

		// Set camera position
		camera.position.x = dim["x"]*1.5;
		camera.position.y = dim["y"]*1.5;
		camera.position.z = dim["z"]*1.5;
		
		// Setup listener
		window.addEventListener( 'resize', onWindowResize, false );

		// Setup voxel traversal algorithm
		var backProj = new Backprojection(getReceivers(), 
			getAdvertisers());
		backProj.updateLinks(createRandData());
		var wMat = backProj.projection;
		wMat = clearVerticalBorder(wMat);

		/* 			Test 			*/
		updateColor(wMat);
		/* 			End test 		*/
	}

	function onWindowResize() {
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();
		renderer.setPixelRatio( window.devicePixelRatio );
		renderer.setSize( window.innerWidth, window.innerHeight );
	}

	function createRandData() {
		var data = [];
		var len = getReceivers().shape[0]*getAdvertisers().shape[0];
		for(i = 0; i < len; i++) {
			if(i % 2 == 0) {
				data[i] = getRandom()*100;	
			} else {
				data[i] = 0;
			}
			
		}
		return data;
	}

	function getRandom() {
	  	return Math.random();
	}


	function setColor(cube, color) {
		cube.material.color = new THREE.Color("hsl(" + color + ", 100%, 50%)");
	}

	function setOpacity(cube, op) {
		cube.material.opacity = op;
	}

	function percentToColor(percent, start, end) {
		var ratio = percent/100;
		var scale = (end - start) * ratio;
		var color = scale + start;
		return color;
	}

	function percentToOpacity(percent, start, end) {
		var ratio = percent/100;
		var scale = (end - start) * ratio;
		var opacity = scale + start;
		return opacity;
	}

	function getReceivers() {
		var recv = nj.array([[8, 5, 1], [8, 5, 15], 
							[1, 5, 8], [15, 5, 8]]);
		return recv;
	}

	function getAdvertisers() {
		var adv = nj.array([[4, 7, 1], [4, 7, 15], 
							[12, 7, 1], [12, 7, 15],
							[1, 7, 4], [15, 7, 4], 
							[1, 7, 12], [15, 7, 12],
							[4, 3, 1], [4, 3, 15], 
							[12, 3, 1], [12, 3, 15],
							[1, 3, 4], [15, 3, 4],
							[1, 3, 12], [15, 3, 12]]);
		return adv;
	}

	function clearVerticalBorder(data) {
		for(posx = 1; posx <= dim["x"]; posx++) {
			for(posy = 1; posy <= dim["y"]; posy++) {
				for(posz = 1; posz <= dim["z"]; posz++) {
					if(posx == 1 || posx == dim["x"] || posz == 1 || 
						posz == dim["z"]) {
						data.set(posx-1, posy-1, posz-1, 0);
					}
				}
			}
		}
		return data;
	}

	function updateColor(data) {
		// Max value
		var max = data.max();
		//console.log("Max", max);

		// Change color
		for(i = 0; i < cubeGroup.children.length; i++) {
			// Get cube position
			var posx = cubeGroup.children[i].position.x;
			var posy = cubeGroup.children[i].position.y;
			var posz = cubeGroup.children[i].position.z;

			// Get value from data
			var num = data.get(posx, posy, posz);
			//console.log("num: ", num);

			var percent = (num/max)*100;
			

			var cubeColor = percentToColor(percent,220,0);
			// 240 	blue
			// 0 	red

			var cubeOpacity = percentToOpacity(percent,0.01,1);
			// 0 	Not visible (fully transparent)
			// 1 	no transparency

			// Set visual parameters
			setColor(cubeGroup.children[i], cubeColor);
			setOpacity(cubeGroup.children[i], cubeOpacity);
		}
	}

	function render() {
		requestAnimationFrame( render );
		renderer.render(scene, camera);
		controls.update();
	}

	</script>

</body>

</html>
