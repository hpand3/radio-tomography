<!DOCTYPE html>
<html>
<head>
	<title>3D Radio Tomography</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
		html, body {
		    width: 100%;
		    height: 100%;
		    margin: 0;
		}
		canvas { 
			display: block;
			position: absolute;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
			width: 100%;
			height: 100%;
			overflow: hidden;   /* Disable scrollbars */
			z-index: -1;
		}
	</style>

</head>

<body>

	<script type="text/javascript" src="js/three.js"></script>
	<script type="text/javascript" src="js/OrbitControls.js"></script>
	<script type="text/javascript" src="js/numjs.min.js"></script>
	<script type="text/javascript" src="js/VoxelTraversal.js"></script>
	<script>
	// Dimensions
	var dim = {x:10 , y:10 , z:10};
	var scene,
		renderer,
		cubeGroup,
		wireGroup,
		voxelTrav,
		controls;

	init();
	render();

	function init() {
		// Scene
		scene = new THREE.Scene();

		// Camera
		camera = new THREE.PerspectiveCamera( 65, window.innerWidth/window.innerHeight, 0.1, 1000 );

		// Controls
		controls = new THREE.OrbitControls( camera );
		controls.rotateSpeed = 1.0;
		controls.zoomSpeed = 1.2;
		controls.panSpeed = 0.8;
		controls.target.set(dim["x"]/2, dim["y"]/2, dim["z"]/2);



		// Renderer
		renderer = new THREE.WebGLRenderer();
		renderer.setPixelRatio( window.devicePixelRatio );
		renderer.setSize( window.innerWidth, window.innerHeight );
		renderer.setClearColor (0xe8e8e8, 1);
		document.body.appendChild( renderer.domElement );

		// Init vars
		var cubeGeo = new THREE.CubeGeometry( 1, 1, 1 );
		var wireGeo = new THREE.EdgesGeometry( cubeGeo );
		var wireMat = new THREE.LineBasicMaterial( { color: 
						0x000000, transparent: true, opacity: 0.1 } );

		// Mesh group
		cubeGroup = new THREE.Group();
		wireGroup = new THREE.Group();

		// Create cube structure depending on the dimensions
		for(posx = 0; posx < dim["x"]; posx++) {
			for(posy = 0; posy < dim["y"]; posy++) {
				for(posz = 0; posz < dim["z"]; posz++) {
					// Create objects
					var cubeMat = new THREE.MeshBasicMaterial( { color: 
						0xe00b0b, transparent:true, opacity:0.1 } );
					var cube = new THREE.Mesh( cubeGeo, cubeMat );
					var wireframe = new THREE.LineSegments( wireGeo, 
						wireMat );

					// Set cube position
					cube.position.x = posx;
					cube.position.y = posy;
					cube.position.z = posz;

					// Set wireframe position
					wireframe.position.x = posx;
					wireframe.position.y = posy;
					wireframe.position.z = posz;

					// Add to group
					cubeGroup.add( cube );
					wireGroup.add( wireframe );
				}
			}
		}

		// Add groups to the scene
		scene.add(cubeGroup);
		scene.add(wireGroup);

		// Set camera position
		camera.position.x = dim["x"]*1.5;
		camera.position.y = dim["y"]*1.5;
		camera.position.z = dim["z"]*1.5;
		
		// Setup listener
		window.addEventListener( 'resize', onWindowResize, false );

		// Setup voxel traversal algorithm
		voxelTrav = new VoxelTraversal(dim["x"], dim["y"], dim["z"]);
		var from = nj.array([10,10,10]);
		var to = nj.array([1,5,8]);
		var voxels = voxelTrav.getVoxels(from, to);
		var wMat = createWeightedMatrix(voxels);

		/* 			Test 			*/
		updateColor(wMat);
		/* 			End test 		*/
	};

	function setColor(cube, color) {
		cube.material.color = new THREE.Color("hsl(" + color + ", 100%, 50%)");
	}

	function setOpacity(cube, op) {
		cube.material.opacity = op;
	};

	function percentToColor(percent, start, end) {
		var ratio = percent/100;
		var scale = (end - start) * ratio;
		var color = scale + start;
		return color;
	}

	function percentToOpacity(percent, start, end) {
		var ratio = percent/100;
		var scale = (end - start) * ratio;
		var opacity = scale + start;
		return opacity;
	}

	function createWeightedMatrix(data) {
		var w = nj.zeros([dim["x"], dim["y"], dim["z"]]);
		var len = data.selection.data.length;
		for(i = 0; i < len; i++) {
			var x = data.get(i).get(0);
			var y = data.get(i).get(1);
			var z = data.get(i).get(2);
			//console.log("X: ", x, "Y: ", y, "Z: ", z);
			w.set(x-1, y-1, z-1, 1);
		}
		return w;
	}

	function createRandData() {
		var data = nj.zeros([dim["x"], dim["y"], dim["z"]]);
		for(posx = 0; posx < dim["x"]; posx++) {
			for(posy = 0; posy < dim["y"]; posy++) {
				for(posz = 0; posz < dim["z"]; posz++) {
					data.set(posx, posy, posz, getRandom()*20);
				}
			}
		}
		return data;
	}

	function getRandom() {
	  	return Math.random();
	}

	function updateColor(data) {
		// Max value
		var max = data.max();

		// Change color
		for(i = 0; i < cubeGroup.children.length; i++) {
			// Get cube position
			var posx = cubeGroup.children[i].position.x;
			var posy = cubeGroup.children[i].position.y;
			var posz = cubeGroup.children[i].position.z;

			// Get value from data
			var num = data.get(posx, posy, posz);

			var percent = (num/max)*100;

			var cubeColor = percentToColor(percent,240,0);
			// 240 	blue
			// 0 	red

			var cubeOpacity = percentToOpacity(percent,0.01,.95);
			// 0 	Not visible (fully transparent)
			// 1 	no transparency

			// Set visual parameters
			setColor(cubeGroup.children[i], cubeColor);
			setOpacity(cubeGroup.children[i], cubeOpacity);
		}
	}

	function render() {
		requestAnimationFrame( render );
		renderer.render(scene, camera);
		controls.update();
	};

	function onWindowResize() {
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();
		renderer.setPixelRatio( window.devicePixelRatio );
		renderer.setSize( window.innerWidth, window.innerHeight );
	}

	</script>

</body>

</html>
